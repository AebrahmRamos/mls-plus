<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLSU Course Offerings Search</title>
    <style>
        /* CSS Variables */
        :root {
            --primary-color: #338000; /* DLSU Green */
            --primary-hover: #2a6800; /* Darker green for hover */
            --gray-light: #f4f4f4;    /* Light background */
            --gray-lighter: #f8f9fa; /* Lighter background for elements */
            --border-color: #ddd;     /* Standard border color */
            --error-color: #d9534f;   /* Red for errors */
            --open-section-bg: #D2EED3; /* Background for open sections */
            --closed-section-bg: #D4F1F9; /* Background for closed sections */
            --shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
            --column-gap: 1.5rem;      /* Gap for masonry layout */
            --checkbox-checked-bg: var(--primary-color);
            --checkbox-border-color: #adb5bd;
            --checkbox-focus-ring: rgba(51, 128, 0, 0.25); /* Light green focus ring */
        }

        /* Global Resets and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; /* System font stack */
            margin: 0;
            padding: 0;
            background-color: var(--gray-light);
            line-height: 1.6;
            color: #333;
        }

        /* Header Styling */
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem 1.5rem;
            text-align: center;
            box-shadow: var(--shadow);
        }
        header h1 {
            font-size: 1.75rem;
            font-weight: 600;
        }

        /* Container and Card Styling */
        .container {
            width: 100%;
            /* max-width: 1280px; Limit maximum width */
            margin: 1.5rem auto;
            padding: 0 1rem;
        }

        .card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1.5rem;
        }

        /* Instructions Box */
        .instructions {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--gray-lighter);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            color: #555;
        }
        .instructions code { /* Style inline code */
             background-color: #e9ecef;
             padding: 0.1em 0.4em;
             border-radius: 3px;
             font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
             font-size: 85%;
        }

        /* Search Form Styling */
        .search-form {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .search-form input[type="text"],
        .search-form input[type="number"] {
            flex: 1;
            min-width: 250px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .search-form input[type="number"] {
            min-width: 100px;
            max-width: 150px;
        }
        
        .search-form input[type="text"]:focus,
        .search-form input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem var(--checkbox-focus-ring);
        }

        .search-form button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .search-form button:hover {
            background-color: var(--primary-hover);
        }
        
        /* Auto Refresh Controls */
        .auto-refresh-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background-color: var(--gray-lighter);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .auto-refresh-controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-right: 1rem;
        }
        
        .auto-refresh-controls .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-right: 10px;
        }
        
        .auto-refresh-controls .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .auto-refresh-controls .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .auto-refresh-controls .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        .auto-refresh-controls input:checked + .slider {
            background-color: var(--primary-color);
        }
        
        .auto-refresh-controls input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }
        
        .auto-refresh-controls input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .auto-refresh-status {
            font-size: 0.85rem;
            color: #555;
            padding-left: 10px;
            flex-grow: 1;
        }

        /* --- Improved Filter Controls Styling --- */
        .filter-controls {
            display: grid;
            /* Responsive grid: 1 col default, up to 5 cols on large screens */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem; /* Increased gap */
            margin-bottom: 1.5rem;
            padding: 1.25rem; /* Increased padding */
            background-color: var(--gray-lighter);
            border-radius: 6px; /* Slightly more rounded */
            border: 1px solid var(--border-color);
        }

        /* Style for each individual filter group (label + checkbox container) */
        .filter-group {
            /* No specific styles needed unless for spacing inside */
        }

        .filter-group label { /* Label above the checkbox group */
            display: block;
            margin-bottom: 0.5rem; /* More space below label */
            font-weight: 600; /* Bolder label */
            font-size: 0.9rem;
            color: #495057; /* Darker gray */
        }

        /* Container for checkboxes */
        .checkbox-group {
            max-height: 150px; /* Limit height */
            overflow-y: auto;  /* Enable scroll if needed */
            padding: 0.75rem;  /* Padding inside the box */
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white; /* White background for contrast */
            font-size: 0.85rem; /* Smaller font for options */
        }
        /* Custom Scrollbar for Webkit (Chrome, Safari) */
        .checkbox-group::-webkit-scrollbar {
            width: 6px;
        }
        .checkbox-group::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        .checkbox-group::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }
        .checkbox-group::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }
        /* Custom Scrollbar for Firefox */
        .checkbox-group {
            scrollbar-width: thin;
            scrollbar-color: #ccc #f1f1f1;
        }

        /* Styling for each checkbox + label row */
        .checkbox-label {
            display: flex; /* Use flex for alignment */
            align-items: center;
            margin-bottom: 0.5rem; /* Space between options */
            cursor: pointer;
            position: relative; /* Needed for custom checkbox */
            padding-left: 1.75em; /* Space for custom checkbox */
            min-height: 1.25em; /* Ensure height for alignment */
        }
        .checkbox-label:last-child {
            margin-bottom: 0; /* No margin on the last item */
        }

        /* Hide the default checkbox */
        .checkbox-label input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Create a custom checkbox appearance */
        .checkbox-label .custom-checkbox {
            position: absolute;
            top: 0.1em; /* Adjust vertical alignment */
            left: 0;
            height: 1.15em;
            width: 1.15em;
            background-color: #fff;
            border: 1px solid var(--checkbox-border-color);
            border-radius: 3px;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
        }

        /* Style the custom checkbox when the real checkbox is checked */
        .checkbox-label input[type="checkbox"]:checked ~ .custom-checkbox {
            background-color: var(--checkbox-checked-bg);
            border-color: var(--checkbox-checked-bg);
        }

         /* Style the custom checkbox on hover */
        .checkbox-label:hover input[type="checkbox"] ~ .custom-checkbox {
            border-color: var(--primary-color);
        }

        /* Create the checkmark/indicator (hidden when not checked) */
        .custom-checkbox::after {
            content: "";
            position: absolute;
            display: none;
            left: 0.35em;
            top: 0.1em;
            width: 0.3em;
            height: 0.6em;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        /* Display the checkmark when checked */
        .checkbox-label input[type="checkbox"]:checked ~ .custom-checkbox::after {
            display: block;
        }

        /* Focus style for accessibility */
         .checkbox-label input[type="checkbox"]:focus ~ .custom-checkbox {
             box-shadow: 0 0 0 0.2rem var(--checkbox-focus-ring);
         }
         .checkbox-label input[type="checkbox"]:focus:not(:checked) ~ .custom-checkbox {
             border-color: var(--primary-color);
         }


        /* Filter Buttons Container */
        .filter-buttons {
            grid-column: 1 / -1; /* Span across all columns */
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            gap: 0.75rem;
            margin-top: 1rem; /* More space above buttons */
        }

        .filter-buttons button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s, opacity 0.2s;
            flex-grow: 1; /* Make buttons share space */
            flex-basis: 120px; /* Minimum width before wrapping */
            text-align: center;
        }

        .filter-buttons button:hover {
            background-color: var(--primary-hover);
        }
        .filter-buttons button:active {
             opacity: 0.9;
        }

        .filter-buttons button.clear-filters {
            background-color: #6c757d; /* Bootstrap secondary color */
        }
        .filter-buttons button.clear-filters:hover {
            background-color: #5a6268;
        }
        /* --- End Filter Controls Styling --- */

        /* Filter group for open/closed sections */
        .filter-section-status {
            margin-bottom: 1rem;
        }
        
        .filter-section-status .checkbox-label {
            display: inline-flex;
            margin-right: 1rem;
        }

        /* Loading, Error, No Results Messages */
        .loading, .error, .no-results {
            text-align: center;
            padding: 1.5rem; /* More padding */
            margin: 1.5rem 0;
            border-radius: 4px;
            font-size: 1rem;
        }

        .loading {
            display: none; /* Controlled by JS */
            background-color: var(--gray-lighter);
            color: #555;
        }

        .error {
            color: #721c24; /* Darker red text */
            background-color: #f8d7da; /* Light red background */
            border: 1px solid #f5c6cb; /* Red border */
            display: none; /* Controlled by JS */
        }

        .no-results {
            color: #666;
            background-color: var(--gray-lighter);
            border: 1px solid var(--border-color);
            display: none; /* Controlled by JS */
        }

        /* Results Area - Masonry Layout */
        .results-container {
            /* Using CSS Columns for masonry */
            /* MODIFIED: Changed max columns from 3 to 2 */
            columns: 2 320px; /* Target max 2 columns, min width 320px */
            column-gap: var(--column-gap);
            width: 100%;
        }

        /* Responsive adjustments for columns */
        /* REMOVED: Redundant media query for 2 columns, now handled by the main rule */
        /* @media (max-width: 1024px) { ... } */

        @media (max-width: 767px) {
            .results-container {
                columns: 1; /* Single column on small screens */
            }
            .filter-controls {
                grid-template-columns: 1fr; /* Stack filters */
            }
        }

        /* Individual Course Card in Results */
        .course-container {
            break-inside: avoid; /* Prevent breaking inside a card */
            page-break-inside: avoid;
            margin-bottom: var(--column-gap); /* Space below each card */
            display: inline-block; /* Needed for columns */
            width: 100%;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            padding: 1.25rem; /* Slightly more padding */
            overflow: hidden; /* Contain elements */
        }
        /* Error message styling when inside a course container */
        .course-container.error {
             color: #721c24;
             background-color: #f8d7da;
             border: 1px solid #f5c6cb;
             padding: 1rem;
             text-align: center;
        }


        /* Course Header (Title, Count, Last Updated) */
        .course-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align items to top */
            margin-bottom: 1rem;
            padding-bottom: 0.75rem; /* More padding */
            border-bottom: 2px solid var(--primary-color);
            flex-wrap: wrap; /* Allow wrapping */
            gap: 0.5rem; /* Space between wrapped items */
        }

        .course-title {
            font-size: 1.4rem; /* Larger title */
            color: var(--primary-color);
            font-weight: 600;
            margin-right: 1rem; /* Space after title */
            flex-shrink: 0; /* Prevent title from shrinking too much */
        }
        .course-header span:not(.course-title) { /* Styling for count/updated */
             font-size: 0.85rem;
             color: #555;
             padding-top: 0.2rem; /* Align text better with title */
        }

        .last-updated {
            margin-left: auto; /* Push to the right */
            font-style: italic;
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Responsive Table Wrapper */
        .table-responsive {
            overflow-x: auto; /* Enable horizontal scroll on small screens */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            margin-bottom: 0.5rem;
        }

        /* Sections Table Styling */
        .section-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem; /* Slightly smaller table font */
        }

        .section-table th {
            background-color: var(--primary-color);
            color: white;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            position: sticky; /* Sticky header */
            top: 0;
            z-index: 10; /* Ensure header is above content */
            white-space: nowrap; /* Prevent header text wrapping */
        }

        .section-table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            vertical-align: top; /* Align content to top */
            /* word-break: break-word; Removed, let it scroll */
        }

        /* Alternating Row Colors */
        .section-table tbody tr:nth-child(even) {
            background-color: var(--gray-light);
        }
        .section-table tbody tr:hover { /* Hover effect */
             background-color: #e9ecef;
        }

        /* Open/Closed Section Highlighting */
        .section-table tr.open-section {
            background-color: var(--open-section-bg) !important;
        }
        .section-table tr.closed-section {
            background-color: var(--closed-section-bg) !important;
        }
        .section-table tr.open-section:hover {
             background-color: #bce3be !important; /* Slightly darker green on hover */
        }
        .section-table tr.closed-section:hover {
             background-color: #b6e2f2 !important; /* Slightly darker blue on hover */
        }

        /* Professor Row (if used, currently not in JS) */
        .section-table tr.professor-row {
            background-color: #f9f9f9;
            font-style: italic;
        }
        .professor-cell { /* If used */
            text-align: right;
        }

        /* Legend Styling */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color); /* Separator line */
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .color-box {
            width: 1rem;
            height: 1rem;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1); /* Subtle border */
        }

        .color-box.green {
            background-color: var(--open-section-bg);
        }

        .color-box.blue {
            background-color: var(--closed-section-bg);
        }

        /* Responsive Table Column Hiding */
        @media screen and (max-width: 767px) {
            .section-table th,
            .section-table td {
                padding: 0.6rem; /* Adjust padding */
                font-size: 0.8rem; /* Smaller font on mobile */
            }

            /* Hide specific columns on small screens */
            .hide-on-mobile {
                display: none;
            }
             /* Adjust header font size */
            header h1 {
                font-size: 1.5rem;
            }
            /* Adjust card padding */
            .card {
                padding: 1rem;
            }
            .filter-controls {
                padding: 1rem;
            }
            
            .auto-refresh-controls {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .auto-refresh-controls > * {
                margin-bottom: 0.5rem;
            }
            
            .auto-refresh-status {
                padding-left: 0;
            }
        }

    </style>
</head>
<body class="bg-gray-100 font-sans"> <header>
        <h1>DLSU Course Offerings Search</h1>
    </header>

    <div class="container">
        <div class="card">
            <div class="instructions">
                <p>Enter course codes separated by commas (e.g., <code>CSALGCM</code>, <code>GERIZAL</code>, <code>GELITPH</code>) to search for available sections.</p>
            </div>

            <div class="search-form">
                <input type="text" id="courseCode" placeholder="Enter course codes (e.g., CSALGCM, GERIZAL)" maxlength="200">
                <button id="searchButton">Search</button>
            </div>
            
            <div class="auto-refresh-controls">
                <label class="toggle-switch">
                    <input type="checkbox" id="autoRefreshToggle">
                    <span class="slider"></span>
                </label>
                <span>Auto Refresh:</span>
                <input type="number" id="refreshInterval" min="5" max="3600" value="30" title="Refresh interval in seconds (min: 5s)">
                <span>seconds</span>
                <span id="refreshStatus" class="auto-refresh-status">Auto-refresh is disabled</span>
            </div>

            <div class="filter-controls" id="filterControls" style="display: none;">
                <div class="filter-group">
                    <label>Section Status:</label>
                    <div id="filterSectionStatusContainer" class="filter-section-status">
                        <label class="checkbox-label">
                            <input type="checkbox" name="filterSectionStatus" value="open" checked>
                            <span class="custom-checkbox"></span>
                            Open
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" name="filterSectionStatus" value="closed" checked>
                            <span class="custom-checkbox"></span>
                            Closed
                        </label>
                    </div>
                </div>
                
                <div class="filter-group">
                    <label>Time:</label>
                    <div id="filterTimeContainer" class="checkbox-group">
                        <span class="loading-filters">Loading filters...</span>
                    </div>
                </div>
                <div class="filter-group">
                    <label>Day/s:</label>
                    <div id="filterDayContainer" class="checkbox-group">
                         <span class="loading-filters">Loading filters...</span>
                    </div>
                </div>
                <div class="filter-group">
                    <label>Professor:</label>
                    <div id="filterProfessorContainer" class="checkbox-group">
                         <span class="loading-filters">Loading filters...</span>
                    </div>
                </div>
                <div class="filter-group">
                    <label>Building:</label>
                    <div id="filterBuildingContainer" class="checkbox-group">
                         <span class="loading-filters">Loading filters...</span>
                    </div>
                </div>
                <div class="filter-group">
                    <label>Remarks:</label>
                    <div id="filterRemarksContainer" class="checkbox-group">
                         <span class="loading-filters">Loading filters...</span>
                    </div>
                </div>

                <div class="filter-buttons">
                    <button id="applyFiltersButton">Apply Filters</button>
                    <button id="clearFiltersButton" class="clear-filters">Clear Filters</button>
                </div>
            </div>
            <div class="error" id="errorMessage"></div>
            <div class="loading" id="loadingIndicator">Searching for course offerings...</div>
            <div class="no-results" id="noResultsMessage">No sections match the current filters.</div>

            <div id="resultsContainer" class="results-container">
                </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="color-box green"></div>
                    <span>Open Section</span>
                </div>
                <div class="legend-item">
                    <div class="color-box blue"></div>
                    <span>Closed Section</span>
                </div>
            </div>
        </div>
    </div>

    <footer style="background-color: var(--gray-lighter); padding: 1rem; text-align: center; margin-top: 2rem; border-top: 1px solid var(--border-color);">
        <p style="margin-top: 1rem; font-size: 1rem; color: #333;"> The way DLSU's API is accessed lies in a gray area. Use at your own discretion. The developer is not responsible for any misuse or consequences arising from its use. For more details, check the README OR <a href="https://instagram.com/AebrahmRamos/" target="_blank" style="color: var(--primary-color); text-decoration: none;">CONTACT ME</a>.</p>
        <p style="font-size: 0.9rem; color: #555;">Developed by <a href="https://www.linkedin.com/in/aebrahmramos/" target="_blank" style="color: var(--primary-color); text-decoration: none;">Aebrahm Ramos</a></p>
        <div style="font-size: 0.8rem; color: #777;">
            <a href="https://github.com/AebrahmRamos/" target="_blank" style="margin-right: 1rem; color: #777; text-decoration: none;">Github Repo</a>
            <a href="https://github.com/AebrahmRamos/" target="_blank" style="color: #777; text-decoration: none;">GitHub</a>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DOM Element References ---
            const searchButton = document.getElementById('searchButton');
            const courseCodeInput = document.getElementById('courseCode');
            const resultsContainer = document.getElementById('resultsContainer');
            const errorMessage = document.getElementById('errorMessage');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const noResultsMessage = document.getElementById('noResultsMessage');
            const filterControls = document.getElementById('filterControls');
            const filterTimeContainer = document.getElementById('filterTimeContainer');
            const filterDayContainer = document.getElementById('filterDayContainer');
            const filterProfessorContainer = document.getElementById('filterProfessorContainer');
            const filterBuildingContainer = document.getElementById('filterBuildingContainer');
            const filterRemarksContainer = document.getElementById('filterRemarksContainer');
            const filterSectionStatusContainer = document.getElementById('filterSectionStatusContainer');
            const applyFiltersButton = document.getElementById('applyFiltersButton');
            const clearFiltersButton = document.getElementById('clearFiltersButton');
            const autoRefreshToggle = document.getElementById('autoRefreshToggle');
            const refreshInterval = document.getElementById('refreshInterval');
            const refreshStatus = document.getElementById('refreshStatus');

            // --- State Variables ---
            const proxyUrl = '/api/search'; // Replace with your actual API endpoint if needed
            let allFetchedData = []; // Stores the raw data from all successful searches
            let autoRefreshTimer = null; // To store the timer for auto-refresh
            let lastSearchCourseCodes = []; // Store the last search queries for auto-refresh
            let currentFilters = {}; // Store current applied filters
            
            // Load saved filter preferences from localStorage
            const savedFilters = loadSavedFilters();

            // --- Event Listeners ---
            searchButton.addEventListener('click', searchCourses);
            applyFiltersButton.addEventListener('click', applyFilters);
            clearFiltersButton.addEventListener('click', clearFilters);
            courseCodeInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchCourses(); // Trigger search on Enter key
                }
            });
            
            // Auto-refresh toggle event listener
            autoRefreshToggle.addEventListener('change', function() {
                if (this.checked) {
                    startAutoRefresh();
                } else {
                    stopAutoRefresh();
                }
            });
            
            // Interval input change listener
            refreshInterval.addEventListener('change', function() {
                // Enforce minimum value
                if (this.value < 5) {
                    this.value = 5;
                }
                
                // If auto-refresh is on, restart with new interval
                if (autoRefreshToggle.checked) {
                    stopAutoRefresh();
                    startAutoRefresh();
                }
            });

            /**
             * Loads saved filter preferences from localStorage
             * Only loads time, day, and section status filters as specified
             */
            function loadSavedFilters() {
                try {
                    const savedFiltersStr = localStorage.getItem('dlsuCourseSearchFilters');
                    if (savedFiltersStr) {
                        return JSON.parse(savedFiltersStr);
                    }
                } catch (e) {
                    console.error('Error loading saved filters:', e);
                }
                return {
                    times: [],
                    days: [],
                    sectionStatus: ['open', 'closed'] // Default to both selected
                };
            }
            
            /**
             * Saves current filter selections to localStorage
             * Only saves time, day, and section status filters as specified
             */
            function saveFilterPreferences() {
                const filtersToSave = {
                    times: getSelectedCheckboxValues('filterTimeContainer'),
                    days: getSelectedCheckboxValues('filterDayContainer'),
                    sectionStatus: getSelectedCheckboxValues('filterSectionStatusContainer')
                };
                
                try {
                    localStorage.setItem('dlsuCourseSearchFilters', JSON.stringify(filtersToSave));
                } catch (e) {
                    console.error('Error saving filter preferences:', e);
                }
            }
            
            // --- Core Functions ---
            
            /**
             * Starts the auto-refresh timer
             */
            function startAutoRefresh() {
                if (lastSearchCourseCodes.length === 0) {
                    // No search has been performed yet
                    refreshStatus.textContent = "Auto-refresh ready (perform a search first)";
                    return;
                }
                
                // Clear any existing timer
                stopAutoRefresh();
                
                // Get interval in milliseconds (minimum 5 seconds)
                const intervalMs = Math.max(5, parseInt(refreshInterval.value, 10)) * 1000;
                
                // Set up new timer
                autoRefreshTimer = setInterval(() => {
                    refreshStatus.textContent = `Auto-refreshing... (every ${refreshInterval.value}s)`;
                    performAutoRefresh();
                }, intervalMs);
                
                refreshStatus.textContent = `Auto-refresh active (every ${refreshInterval.value}s)`;
            }
            
            /**
             * Stops the auto-refresh timer
             */
            function stopAutoRefresh() {
                if (autoRefreshTimer) {
                    clearInterval(autoRefreshTimer);
                    autoRefreshTimer = null;
                }
                refreshStatus.textContent = "Auto-refresh is disabled";
            }
            
            /**
             * Performs an auto-refresh using the last search parameters
             */
            function performAutoRefresh() {
                if (lastSearchCourseCodes.length === 0) return;
                
                // Create fetch promises for each course code
                const promises = lastSearchCourseCodes.map(fetchCourseOfferings);
                
                // Process results once all fetches are complete - silently
                Promise.all(promises)
                    .then(results => {
                        let hasValidData = false;
                        
                        allFetchedData = []; // Clear previous successful data
                        
                        results.forEach(data => {
                            if (!data.error && data.sections && data.sections.length > 0) {
                                // Store valid data
                                allFetchedData.push(data);
                                hasValidData = true;
                            }
                        });
                        
                        if (hasValidData) {
                            // Re-apply any active filters
                            applyStoredFilters();
                            
                            // Add timestamp to status
                            const now = new Date();
                            const timeStr = now.toLocaleTimeString();
                            refreshStatus.textContent = `Last auto-refresh: ${timeStr} (every ${refreshInterval.value}s)`;
                        }
                    })
                    .catch(error => {
                        console.error('Auto-refresh error:', error);
                        refreshStatus.textContent = `Auto-refresh error: ${error.message} (retrying in ${refreshInterval.value}s)`;
                    });
            }
            
            /**
             * Re-applies the stored filters to the refreshed data
             */
            function applyStoredFilters() {
                // Get current filters if any are active
                const selectedFilters = {
                    times: getSelectedCheckboxValues('filterTimeContainer'),
                    days: getSelectedCheckboxValues('filterDayContainer'),
                    professors: getSelectedCheckboxValues('filterProfessorContainer'),
                    buildings: getSelectedCheckboxValues('filterBuildingContainer'),
                    remarks: getSelectedCheckboxValues('filterRemarksContainer'),
                    sectionStatus: getSelectedCheckboxValues('filterSectionStatusContainer')
                };
                
                // Store current filters
                currentFilters = selectedFilters;
                
                // Filter data based on selections if any are active
                let filteredData = allFetchedData;
                
                const hasActiveFilters = Object.values(selectedFilters).some(arr => arr.length > 0);
                
                if (hasActiveFilters) {
                    filteredData = allFetchedData.map(course => {
                        if (!course || !course.sections) return null;
                        
                        const filteredSections = course.sections.filter(section => {
                            // Check if the section is open/closed based on selection
                            const isOpen = determineIfSectionIsOpen(section);
                            const statusMatch = selectedFilters.sectionStatus.length === 0 || 
                                               (isOpen && selectedFilters.sectionStatus.includes('open')) || 
                                               (!isOpen && selectedFilters.sectionStatus.includes('closed'));
                                               
                            // Check if the section matches the selected criteria for each filter type
                            const timeMatch = selectedFilters.times.length === 0 || section.times?.some(t => selectedFilters.times.includes(t));
                            const dayMatch = selectedFilters.days.length === 0 || section.days?.some(d => selectedFilters.days.includes(d));
                            const profMatch = selectedFilters.professors.length === 0 || selectedFilters.professors.includes(section.professor);
                            const buildingMatch = selectedFilters.buildings.length === 0 || section.rooms?.some(r => selectedFilters.buildings.includes(extractBuilding(r)));
                            const remarksMatch = selectedFilters.remarks.length === 0 || selectedFilters.remarks.includes(section.remarks);
                            
                            // Section must match all active filters
                            return statusMatch && timeMatch && dayMatch && profMatch && buildingMatch && remarksMatch;
                        });
                        
                        return filteredSections.length > 0 ? { ...course, sections: filteredSections } : null;
                    }).filter(course => course !== null);
                }
                
                renderResults(filteredData);
            }

            /**
             * Initiates the course search process based on user input.
             */
            function searchCourses() {
                const courseCodes = courseCodeInput.value.trim().toUpperCase().split(',')
                                        .map(code => code.trim()).filter(code => code !== ''); // Clean up input

                if (courseCodes.length === 0) {
                    showError('Please enter at least one course code.');
                    return;
                }
                
                // Store search for auto-refresh
                lastSearchCourseCodes = [...courseCodes];
                
                // If auto-refresh is enabled, restart with new search terms
                if (autoRefreshToggle.checked) {
                    stopAutoRefresh();
                }

                // Reset UI state for new search
                resetUIBeforeSearch();

                // Create fetch promises for each course code
                const promises = courseCodes.map(fetchCourseOfferings);

                showLoading();

                // Process results once all fetches are complete
                Promise.all(promises)
                    .then(handleFetchResults)
                    .catch(error => {
                        hideLoading();
                        showError(`An unexpected error occurred during search: ${error.message}`);
                        console.error('Search processing error:', error);
                    })
                    .finally(() => {
                        // If auto-refresh was enabled, restart it
                        if (autoRefreshToggle.checked) {
                            startAutoRefresh();
                        }
                    });
            }

            /**
             * Fetches course offering data for a single course code.
             * @param {string} courseCode - The course code to search for.
             * @returns {Promise<object>} - A promise resolving to the course data or an error object.
             */
            async function fetchCourseOfferings(courseCode) {
                try {
                    // --- IMPORTANT ---
                    // Replace this URL with your actual backend API endpoint
                    // Example: const apiUrl = `https://your-api.com/search?course=${encodeURIComponent(courseCode)}`;
                    // For local testing using a proxy, '/api/search' might be correct if set up.
                    const apiUrl = `${proxyUrl}?course=${encodeURIComponent(courseCode)}`;
                    // --- END IMPORTANT ---

                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'ngrok-skip-browser-warning': 'true'
                        }
                    });

                    if (!response.ok) {
                        // Try to get error message from response body if possible
                        let errorMsg = `Server error: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            errorMsg = errorData.message || errorMsg;
                        } catch (e) { /* Ignore if response is not JSON */ }
                        throw new Error(errorMsg);
                    }

                    const data = await response.json();
                    // Ensure courseCode is attached, even if API doesn't return it
                    if (!data.courseCode) {
                        data.courseCode = courseCode;
                    }
                    return data;
                } catch (error) {
                    console.error(`Fetch error for ${courseCode}:`, error);
                    // Return a structured error object for consistent handling
                    return { error: true, courseCode: courseCode, message: error.message };
                }
            }

            /**
             * Handles the results from all fetch promises.
             * @param {Array<object>} results - An array of results from fetchCourseOfferings.
             */
            function handleFetchResults(results) {
                hideLoading();
                let hasValidData = false;
                let hasErrors = false;

                allFetchedData = []; // Clear previous successful data

                results.forEach(data => {
                    if (data.error) {
                        // Display error specific to this course fetch
                        displayCourseSpecificError(data.courseCode, data.message || 'Failed to fetch course offerings');
                        hasErrors = true;
                    } else if (data.noResults || !data.sections || data.sections.length === 0) {
                        // Display "no results" specific to this course
                        displayCourseSpecificNoResults(data.courseCode);
                    } else {
                        // Store valid data
                        allFetchedData.push(data);
                        hasValidData = true;
                    }
                });

                if (hasValidData) {
                    populateFilters(); // Create filter options based on ALL fetched data
                    filterControls.style.display = 'grid'; // Show filter section
                    renderResults(allFetchedData); // Render initial results
                } else if (!hasErrors && resultsContainer.children.length === 0) {
                    // If no valid data, no errors displayed, and no "no results" messages shown
                    showError('No course sections found for the requested courses, or failed to fetch data.');
                } else if (!hasValidData && hasErrors && resultsContainer.children.length === 0) {
                     // If only errors occurred and nothing else was displayed
                     showError('Failed to fetch data for all requested courses.');
                }
                 // If only "no results" messages were shown, no general error/message is needed.
            }


            /**
             * Populates the filter checkboxes based on the collected data.
             */
            function populateFilters() {
                const filters = {
                    times: new Set(),
                    days: new Set(),
                    professors: new Set(),
                    buildings: new Set(),
                    remarks: new Set()
                };

                // Collect unique values for each filter category
                allFetchedData.forEach(course => {
                    if (!course || !course.sections) return;
                    course.sections.forEach(section => {
                        section.times?.forEach(time => { if (time) filters.times.add(time); });
                        section.days?.forEach(day => { if (day) filters.days.add(day); });
                        if (section.professor) filters.professors.add(section.professor);
                        section.rooms?.forEach(room => {
                            const building = extractBuilding(room);
                            if (building) filters.buildings.add(building);
                        });
                        if (section.remarks) filters.remarks.add(section.remarks);
                    });
                });

                // Generate checkboxes for each category and check all by default
                generateCheckboxes(filterTimeContainer, [...filters.times].sort(), savedFilters.times);
                generateCheckboxes(filterDayContainer, [...filters.days].sort(), savedFilters.days);
                generateCheckboxes(filterProfessorContainer, [...filters.professors].sort(), [], true);
                generateCheckboxes(filterBuildingContainer, [...filters.buildings].sort(), [], true);
                generateCheckboxes(filterRemarksContainer, [...filters.remarks].sort(), [], true);
                
                // Section status checkboxes are handled in HTML, just need to update checked state from saved filters
                const openStatusCheckbox = filterSectionStatusContainer.querySelector('input[value="open"]');
                const closedStatusCheckbox = filterSectionStatusContainer.querySelector('input[value="closed"]');
                
                if (openStatusCheckbox && closedStatusCheckbox) {
                    openStatusCheckbox.checked = savedFilters.sectionStatus.includes('open');
                    closedStatusCheckbox.checked = savedFilters.sectionStatus.includes('closed');
                }
            }

            /**
             * Generates checkbox elements for a given filter category.
             * @param {HTMLElement} container - The container element for the checkboxes.
             * @param {Array<string>} options - An array of unique string options.
             * @param {Array<string>} savedValues - Previously saved values to check by default
             * @param {boolean} checkAll - Whether to check all boxes by default (true if no savedValues)
             */
            function generateCheckboxes(container, options, savedValues = [], checkAll = true) {
                container.innerHTML = ''; // Clear previous content (like "Loading filters...")
                if (options.length === 0) {
                    container.innerHTML = '<span class="no-options">N/A</span>'; // Indicate if no options
                    return;
                }
                
                const hasSavedValues = Array.isArray(savedValues) && savedValues.length > 0;
                
                options.forEach(option => {
                    const label = document.createElement('label');
                    label.classList.add('checkbox-label'); // Class for styling

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = option;
                    
                    // Check the box if:
                    // 1. We have saved values and this option is in the saved values
                    // 2. OR if we don't have saved values and checkAll is true
                    checkbox.checked = hasSavedValues ? 
                        savedValues.includes(option) : 
                        checkAll;
                        
                    checkbox.name = container.id.replace('Container', ''); // e.g., 'filterTime'

                    const customCheckbox = document.createElement('span');
                    customCheckbox.classList.add('custom-checkbox'); // Class for the styled checkbox

                    label.appendChild(checkbox);
                    label.appendChild(customCheckbox); // Add the custom span
                    label.appendChild(document.createTextNode(` ${option}`)); // Add space and text

                    container.appendChild(label);
                });
            }

            /**
             * Applies the selected filters to the displayed results.
             */
            function applyFilters() {
                // Get selected values from checkboxes for each category
                const selectedFilters = {
                    times: getSelectedCheckboxValues('filterTimeContainer'),
                    days: getSelectedCheckboxValues('filterDayContainer'),
                    professors: getSelectedCheckboxValues('filterProfessorContainer'),
                    buildings: getSelectedCheckboxValues('filterBuildingContainer'),
                    remarks: getSelectedCheckboxValues('filterRemarksContainer'),
                    sectionStatus: getSelectedCheckboxValues('filterSectionStatusContainer')
                };

                // Save time, day, and section status filter preferences
                saveFilterPreferences();

                // Filter the `allFetchedData` based on selections
                const filteredData = allFetchedData.map(course => {
                    if (!course || !course.sections) return null; // Skip if course data is invalid

                    const filteredSections = course.sections.filter(section => {
                        // Check if the section is open/closed based on selection
                        const isOpen = determineIfSectionIsOpen(section);
                        const statusMatch = selectedFilters.sectionStatus.length === 0 || 
                                           (isOpen && selectedFilters.sectionStatus.includes('open')) || 
                                           (!isOpen && selectedFilters.sectionStatus.includes('closed'));
                                           
                        // Check if the section matches the selected criteria for each filter type
                        const timeMatch = selectedFilters.times.length === 0 || section.times?.some(t => selectedFilters.times.includes(t));
                        const dayMatch = selectedFilters.days.length === 0 || section.days?.some(d => selectedFilters.days.includes(d));
                        const profMatch = selectedFilters.professors.length === 0 || selectedFilters.professors.includes(section.professor);
                        const buildingMatch = selectedFilters.buildings.length === 0 || section.rooms?.some(r => selectedFilters.buildings.includes(extractBuilding(r)));
                        const remarksMatch = selectedFilters.remarks.length === 0 || selectedFilters.remarks.includes(section.remarks);

                        // Section must match all active filters
                        return statusMatch && timeMatch && dayMatch && profMatch && buildingMatch && remarksMatch;
                    });

                    // Return the course with only the filtered sections, or null if no sections match
                    return filteredSections.length > 0 ? { ...course, sections: filteredSections } : null;

                }).filter(course => course !== null); // Remove courses that became null (no matching sections)

                renderResults(filteredData); // Render the filtered data
                
                // Store current filters for auto-refresh
                currentFilters = selectedFilters;
            }
            
            /**
             * Determines if a section should be considered "open" based on enrollment and capacity
             * @param {object} section - The section object to check
             * @returns {boolean} - True if the section is open, false if closed
             */
            function determineIfSectionIsOpen(section) {
                // If isOpen is already explicitly set, use that
                if (typeof section.isOpen === 'boolean') {
                    // If enrolled equals capacity, override to closed
                    if (section.enrolled !== undefined && 
                        section.enrlCap !== undefined && 
                        section.enrolled === section.enrlCap) {
                        return false;
                    }
                    return section.isOpen;
                }
                
                // Otherwise determine based on enrollment vs. capacity
                if (section.enrolled !== undefined && section.enrlCap !== undefined) {
                    return section.enrolled < section.enrlCap;
                }
                
                // Default to closed if we can't determine
                return false;
            }

            /**
             * Clears all selected filters and re-renders the original full results.
             */
            function clearFilters() {
                resetFilters(); // Uncheck all checkboxes
                hideNoResults(); // Hide the "no results" message
                renderResults(allFetchedData); // Re-render with original full data
                
                // Save the cleared state
                saveFilterPreferences();
            }

            /**
             * Renders the course data (either full or filtered) into the results container.
             * @param {Array<object>} dataToRender - Array of course objects to display.
             */
            function renderResults(dataToRender) {
                resultsContainer.innerHTML = ''; // Clear previous results
                hideNoResults(); // Hide no results message initially

                let totalSectionsDisplayed = 0;

                if (!dataToRender || dataToRender.length === 0) {
                    if (allFetchedData.length > 0) { // Check if there was data initially but filters removed it all
                       showNoResults();
                    } else {
                        // This case is usually handled by handleFetchResults, but added as a fallback.
                        // Avoid showing error if specific course errors/no-results were already shown.
                        if (resultsContainer.children.length === 0) {
                             showError("No course data available to display.");
                        }
                    }
                    return;
                }

                // Render each course that has sections
                dataToRender.forEach(data => {
                    if (data && data.sections && data.sections.length > 0) {
                        displayCourseSections(data); // Display this course's sections
                        totalSectionsDisplayed += data.sections.length;
                    }
                });

                // If filtering resulted in zero sections across all originally fetched courses
                if (totalSectionsDisplayed === 0 && allFetchedData.length > 0) {
                    showNoResults();
                }
            }

            /**
             * Creates and appends the HTML structure for a single course's sections.
             * @param {object} data - The course data object including sections.
             */
            function displayCourseSections(data) {
                const courseCode = data.courseCode;
                const courseContainer = document.createElement('div');
                courseContainer.classList.add('course-container');

                // --- Course Header ---
                const courseHeader = document.createElement('div');
                courseHeader.classList.add('course-header');

                const courseTitle = document.createElement('h2');
                courseTitle.classList.add('course-title');
                courseTitle.textContent = `${courseCode}`; // Just the code for brevity
                courseHeader.appendChild(courseTitle);

                const sectionInfo = document.createElement('span');
                const openSectionsCount = data.sections.filter(s => s.isOpen).length;
                sectionInfo.textContent = `(${openSectionsCount}/${data.sections.length} open)`;
                courseHeader.appendChild(sectionInfo);

                if (data.lastUpdated) {
                    const lastUpdatedInfo = document.createElement('span');
                    lastUpdatedInfo.classList.add('last-updated');
                    lastUpdatedInfo.textContent = `Updated: ${formatTimeAgo(data.lastUpdated)}`;
                    courseHeader.appendChild(lastUpdatedInfo);
                }
                courseContainer.appendChild(courseHeader);

                // --- Table ---
                const tableWrapper = document.createElement('div');
                tableWrapper.classList.add('table-responsive');

                const table = document.createElement('table');
                table.classList.add('section-table');

                // Table Head
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = [ // Define headers and mobile visibility
                    { text: 'Class#', mobile: true },
                    { text: 'Section', mobile: true },
                    { text: 'Day/s', mobile: true },
                    { text: 'Time', mobile: true },
                    { text: 'Room', mobile: true },
                    { text: 'Professor', mobile: true }, // Added professor column
                    { text: 'Cap', mobile: false }, // Hide Cap on mobile
                    { text: 'Enrolled', mobile: true },
                    { text: 'Remarks', mobile: false } // Hide Remarks on mobile
                ];
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header.text;
                    if (!header.mobile) {
                        th.classList.add('hide-on-mobile'); // Add class to hide
                    }
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Table Body
                const tbody = document.createElement('tbody');
                data.sections.forEach(section => {
                    // Determine if the section is open using our helper function
                    const isOpen = determineIfSectionIsOpen(section);
                    const rowClass = isOpen ? 'open-section' : 'closed-section';
                    const numRows = Math.max(section.days?.length || 1, section.times?.length || 1, section.rooms?.length || 1);

                    for (let i = 0; i < numRows; i++) {
                        const row = document.createElement('tr');
                        if (rowClass) row.classList.add(rowClass);

                        // Add cells common to the section (only on the first row)
                        if (i === 0) {
                            appendCell(row, section.classNbr || 'N/A', numRows);
                            appendCell(row, section.section || 'N/A', numRows);
                        }

                        // Add cells that can have multiple values
                        appendCell(row, section.days?.[i] || '');
                        appendCell(row, section.times?.[i] || '');
                        appendCell(row, section.rooms?.[i] || '');

                        // Add remaining common cells (only on the first row)
                        if (i === 0) {
                            appendCell(row, section.professor || 'TBA', numRows); // Added professor cell
                            appendCell(row, section.enrlCap ?? 'N/A', numRows, true); // Hide on mobile
                            appendCell(row, section.enrolled ?? 'N/A', numRows);
                            appendCell(row, section.remarks || '', numRows, true); // Hide on mobile
                        }
                        tbody.appendChild(row);
                    }
                    // Remove the professor row since it's now in the table
                    /* if (section.professor) { ... } */
                });

                table.appendChild(tbody);
                tableWrapper.appendChild(table);
                courseContainer.appendChild(tableWrapper);

                resultsContainer.appendChild(courseContainer); // Add the complete course card to the results area
            }

            // --- UI Helper Functions ---

            /** Resets UI elements before a new search */
            function resetUIBeforeSearch() {
                resultsContainer.innerHTML = ''; // Clear results
                hideError();
                hideNoResults();
                hideLoading();
                filterControls.style.display = 'none'; // Hide filters
                // Clear previous filter options visually
                const filterContainers = [filterTimeContainer, filterDayContainer, filterProfessorContainer, filterBuildingContainer, filterRemarksContainer];
                filterContainers.forEach(container => {
                    container.innerHTML = '<span class="loading-filters">Loading filters...</span>';
                });
            }

            /** Unchecks all filter checkboxes */
            function resetFilters() {
                const checkboxes = filterControls.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => checkbox.checked = false);
            }

            /** Shows the loading indicator */
            function showLoading() {
                loadingIndicator.style.display = 'block';
            }

            /** Hides the loading indicator */
            function hideLoading() {
                loadingIndicator.style.display = 'none';
            }

            /** Shows the main error message */
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }

            /** Hides the main error message */
            function hideError() {
                errorMessage.style.display = 'none';
                errorMessage.textContent = '';
            }

            /** Shows the "no results" message */
            function showNoResults() {
                noResultsMessage.style.display = 'block';
            }

            /** Hides the "no results" message */
            function hideNoResults() {
                noResultsMessage.style.display = 'none';
            }

            /** Displays an error message within a course card */
            function displayCourseSpecificError(courseCode, message) {
                const errorContainer = document.createElement('div');
                errorContainer.classList.add('course-container', 'error'); // Use card structure but with error class
                errorContainer.textContent = `Error fetching ${courseCode}: ${message}`;
                resultsContainer.appendChild(errorContainer);
            }

             /** Displays a "no results" message within a course card */
            function displayCourseSpecificNoResults(courseCode) {
                const courseContainer = document.createElement('div');
                courseContainer.classList.add('course-container'); // Regular card structure

                const courseHeader = document.createElement('div');
                courseHeader.classList.add('course-header');
                const courseTitle = document.createElement('h2');
                courseTitle.classList.add('course-title');
                courseTitle.textContent = `${courseCode}`;
                courseHeader.appendChild(courseTitle);
                courseContainer.appendChild(courseHeader);

                const noResultsPara = document.createElement('p');
                noResultsPara.textContent = `No course sections found for ${courseCode}.`;
                noResultsPara.style.padding = '1rem 0'; // Add some padding
                courseContainer.appendChild(noResultsPara);

                resultsContainer.appendChild(courseContainer);
            }


            // --- Utility Functions ---

            /**
             * Extracts the building code from a room string.
             * @param {string|null} room - The room string (e.g., "G301", "ONLINE").
             * @returns {string|null} - The uppercase building code or "ONLINE" or null.
             */
            function extractBuilding(room) {
                if (!room || typeof room !== 'string') return null;
                const upperRoom = room.toUpperCase();
                if (upperRoom === 'ONLINE') return 'ONLINE';
                const match = upperRoom.match(/^[A-Z]+/); // Match leading capital letters
                return match ? match[0] : null;
            }

            /**
             * Gets the values of checked checkboxes within a specific container.
             * @param {string} containerId - The ID of the container element.
             * @returns {Array<string>} - An array of values from checked checkboxes.
             */
            function getSelectedCheckboxValues(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return [];
                
                // Special case for section status which uses name attribute
                if (containerId === 'filterSectionStatusContainer') {
                    const checkedBoxes = container.querySelectorAll('input[name="filterSectionStatus"]:checked');
                    return Array.from(checkedBoxes).map(cb => cb.value);
                }
                
                // Standard case for regular filter groups
                const checkedBoxes = container.querySelectorAll('input[type="checkbox"]:checked');
                return Array.from(checkedBoxes).map(cb => cb.value);
            }

            /**
             * Appends a table cell (td) to a row.
             * @param {HTMLTableRowElement} row - The table row element.
             * @param {string} text - The text content for the cell.
             * @param {number} [rowSpan=1] - The rowspan attribute for the cell.
             * @param {boolean} [hideMobile=false] - Whether to add the 'hide-on-mobile' class.
             */
            function appendCell(row, text, rowSpan = 1, hideMobile = false) {
                const cell = document.createElement('td');
                cell.textContent = text;
                if (rowSpan > 1) {
                    cell.rowSpan = rowSpan;
                }
                if (hideMobile) {
                    cell.classList.add('hide-on-mobile');
                }
                row.appendChild(cell);
            }

             /**
             * Formats a timestamp into a relative "time ago" string.
             * @param {string|number} timestamp - The timestamp (ISO string or milliseconds).
             * @returns {string} - Formatted relative time string.
             */
            function formatTimeAgo(timestamp) {
                if (!timestamp) return 'N/A';
                const date = new Date(timestamp);
                const now = new Date();
                const seconds = Math.round((now - date) / 1000);
                const minutes = Math.round(seconds / 60);
                const hours = Math.round(minutes / 60);
                const days = Math.round(hours / 24);

                if (seconds < 60) return 'just now';
                if (minutes < 60) return `${minutes} min ago`;
                if (hours < 24) return `${hours} hr ago`;
                if (days < 7) return `${days} day${days > 1 ? 's' : ''} ago`;
                // Fallback to simple date format for older dates
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }

             /**
             * Checks if the current view is likely mobile based on window width.
             * @returns {boolean} True if window width is <= 767px.
             */
            function isMobileView() {
                return window.innerWidth <= 767;
            }

        }); // End DOMContentLoaded
    </script>

</body>
</html>
